{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"# Scramblery A simple tool to scramble your images or only faces from images or videos. You can find the online demo in javascript here . For more information, please visit the documentation . Note: The Javascript demo doesn't have a face detection algorithm and it's designed to be applied to a single image. If you want to do this for multiple imagees you should use Python. Purpose of Package The Scramblery package offers tools for creating scrambled images from existing images or videos. Users have the flexibility to scramble entire images or target only specific areas, such as faces. This functionality is particularly beneficial in psychological experiments involving facial recognition tasks. With Scramblery, users can automate the scrambling of multiple images, eliminating the tedious manual process traditionally associated with this task. We hope this package significantly contributes to your research endeavors. Motivation Image scrambling plays a crucial role in psychology experiments, enabling researchers to manipulate visual stimuli while maintaining control over certain visual aspects. This manipulation helps eliminate or alter specific features or patterns that may influence participants' perceptions or responses. Scramblery allows for the creation of stimuli that retain general attributes such as luminance, contrast, and spatial layout, but lack identifiable features or objects. This is useful in experiments where researchers wish to control for these specific attributes. The package helps in mitigating biases and confounding variables in stimuli, thereby providing more reliable and valid experimental conditions. The ability to automate this process ensures consistency across stimuli and saves valuable time for researchers. Features Scramble an entire image with a specified degree of scrambling (either by altering pixel values or pixel coordinates). Target scrambling to only the facial area within an image, with customizable levels of scrambling. Extend the scrambling feature to videos, particularly useful for dynamic stimuli in motion-based experiments. Leverage Fourier-based scrambling to disrupt the phase information while maintaining the power spectrum, particularly useful for psychophysical studies. Installation Scramblery is available on PyPI and can be installed using pip. Use the following command in your terminal: Installation The package can be found in pypi. To install the package, run the following command in the terminal: pip install scramblery from scramblery import scramblery Then use the functions as follows to scramble images. I added some examples below. Usage After installation, you can import and use Scramblery as follows: from scramblery import scramblery # To scramble an entire image scramblery.scrambleimage(\"Lena.png\", x_block=10, y_block=10, scramble_type='classic', seed=None, write=True) # To scramble only the facial area within an image scramblery.scrambleface(\"Lena.png\", splits=10, type='pixel', seamless=False, bg=True, seed=None, write=True) # To apply Fourier-based scrambling on an image scramblery.scrambleimage(\"Lena.png\", scramble_type='fourier', scramble_ratio=0.5, seed=None, write=True) # To apply Fourier-based scrambling o only the facial area within an image scramblery.scrambleface(\"lena.png\",splits=10,type='fourier', scramble_ratio=0.5,write=True) # To scramble faces within a video first we need to create a dict. scramble_settings = { 'splits': 25, 'type': 'pixel', 'bg': True, 'seed': None, 'write': False # Should always be False for video processing } scramblery.scramblevideo(\"input_video.mp4\", \"output_video.mp4\", scramble_settings) Contribution We welcome contributions of any kind to Scramblery. If you have ideas for improvement or have found a bug, please don't hesitate to contribute.","title":"Home"},{"location":"#purpose-of-package","text":"The Scramblery package offers tools for creating scrambled images from existing images or videos. Users have the flexibility to scramble entire images or target only specific areas, such as faces. This functionality is particularly beneficial in psychological experiments involving facial recognition tasks. With Scramblery, users can automate the scrambling of multiple images, eliminating the tedious manual process traditionally associated with this task. We hope this package significantly contributes to your research endeavors.","title":"Purpose of Package"},{"location":"#motivation","text":"Image scrambling plays a crucial role in psychology experiments, enabling researchers to manipulate visual stimuli while maintaining control over certain visual aspects. This manipulation helps eliminate or alter specific features or patterns that may influence participants' perceptions or responses. Scramblery allows for the creation of stimuli that retain general attributes such as luminance, contrast, and spatial layout, but lack identifiable features or objects. This is useful in experiments where researchers wish to control for these specific attributes. The package helps in mitigating biases and confounding variables in stimuli, thereby providing more reliable and valid experimental conditions. The ability to automate this process ensures consistency across stimuli and saves valuable time for researchers.","title":"Motivation"},{"location":"#features","text":"Scramble an entire image with a specified degree of scrambling (either by altering pixel values or pixel coordinates). Target scrambling to only the facial area within an image, with customizable levels of scrambling. Extend the scrambling feature to videos, particularly useful for dynamic stimuli in motion-based experiments. Leverage Fourier-based scrambling to disrupt the phase information while maintaining the power spectrum, particularly useful for psychophysical studies.","title":"Features"},{"location":"#installation","text":"Scramblery is available on PyPI and can be installed using pip. Use the following command in your terminal:","title":"Installation"},{"location":"#installation_1","text":"The package can be found in pypi. To install the package, run the following command in the terminal: pip install scramblery from scramblery import scramblery Then use the functions as follows to scramble images. I added some examples below.","title":"Installation"},{"location":"#usage","text":"After installation, you can import and use Scramblery as follows: from scramblery import scramblery # To scramble an entire image scramblery.scrambleimage(\"Lena.png\", x_block=10, y_block=10, scramble_type='classic', seed=None, write=True) # To scramble only the facial area within an image scramblery.scrambleface(\"Lena.png\", splits=10, type='pixel', seamless=False, bg=True, seed=None, write=True) # To apply Fourier-based scrambling on an image scramblery.scrambleimage(\"Lena.png\", scramble_type='fourier', scramble_ratio=0.5, seed=None, write=True) # To apply Fourier-based scrambling o only the facial area within an image scramblery.scrambleface(\"lena.png\",splits=10,type='fourier', scramble_ratio=0.5,write=True) # To scramble faces within a video first we need to create a dict. scramble_settings = { 'splits': 25, 'type': 'pixel', 'bg': True, 'seed': None, 'write': False # Should always be False for video processing } scramblery.scramblevideo(\"input_video.mp4\", \"output_video.mp4\", scramble_settings)","title":"Usage"},{"location":"#contribution","text":"We welcome contributions of any kind to Scramblery. If you have ideas for improvement or have found a bug, please don't hesitate to contribute.","title":"Contribution"},{"location":"api_reference/","text":"Scramblery Functions in Python Maintained by: @altunenes This document outlines the updated functionalities of the Scramblery library, including the newly introduced Fourier scrambling technique and the enhancements made to the video scrambling function. Updates Fourier Scrambling : A novel method for image scrambling that operates in the frequency domain. Unlike traditional scrambling methods that shuffle pixel values or coordinates, Fourier scrambling randomizes the phase information of the image's Fourier transform, thereby disrupting the image's structure while preserving its energy distribution. This method is particularly potent for applications requiring non-reversible image transformations without a significant loss of information content (e.g., privacy preservation, data anonymization). Video Scrambling Enhancements : The scramblevideo function has been overhauled to provide more flexibility and control over the scrambling process. Users can now specify detailed scrambling settings, allowing for different scrambling techniques to be applied throughout a video sequence. This feature is crucial for researchers and practitioners working with video data, where consistent scrambling parameters are necessary across frames. Function Documentation scrambleface def scrambleface(img, splits, type, seamless=False, bg=True, seed=None, write=True, scramble_ratio=1.0): \"\"\" Scramble the facial area of the image. Args: img: input image path or image array splits: number of splits to perform, works differently between square and stack splits type: type of split, \"pixel\", \"stack\", or \"fourier\". Stack works with pixel coordinates, square works with pixel values seamless: if True, uses seamlessClone to blend the scrambled face with the original image bg: if True, uses the background of the original image, if False, replaces the background with a gray color seed: seed for random number generator (default: None) write: if True, writes the output image to disk, if False, returns the output image scramble_ratio: the power of Fourier scrambling (default: 1.0) Usage: scrambleface(\"image.png\", 10, \"fourier\", False, True, None, True, 0.5) \"\"\" scrambleimage def scrambleimage(image_path, x_block=10, y_block=10, scramble_type='classic', seed=None, write=True, **kwargs): \"\"\" Main function to scramble an image based on the specified scramble type. Args: image_path: Path to the input image (with extension). x_block: Number of splits in x-axis. y_block: Number of splits in y-axis. scramble_type: Type of split; valid values are \"classic\", \"pixel\", \"withinblocks\", \"rotate\", \"colormap\", \"gradient\", \"fourier\". seed: Seed for random number generator (default: None). write: Write the image to disk (default: True). **kwargs: Additional keyword arguments specific to scramble types. Returns: If write is True, writes the scrambled image to disk. If write is False, returns the scrambled image. Raises: ValueError: If an invalid scramble_type is provided or image cannot be read. FileNotFoundError: If the image_path does not exist. \"\"\" scramblevideo def scramblevideo(input_video_path, output_video_path=None, scramble_settings=None): \"\"\" Scramble the facial area in a video. Args: input_video_path: Path to the input video. splits: Number of splits to perform on the face. output_video_path: Path where the output video will be saved (if None, the video won't be saved). scramble_settings: Dictionary of settings for the scrambleface function. Usage: scramblevideo(\"input_video.mp4\", 10, \"output_video.mp4\", scramble_settings) \"\"\" Usage Examples Fourier Scrambling The scrambleface and scrambleimage functions now support Fourier scrambling, a method that disrupts the image's visual content without altering its energy spectrum significantly. This technique is particularly useful in situations where the image's overall energy distribution must be maintained for subsequent processing steps (e.g., deep learning applications) or for privacy-preserving transformations. from scramblery import scrambleface, scrambleimage # Scramble the face in the image using the Fourier method scrambled_face = scrambleface(\"face.jpg\", splits=10, type=\"fourier\", scramble_ratio=0.7, write=False) # Scramble the entire image using the Fourier method scrambled_image = scrambleimage(\"image.jpg\", scramble_type=\"fourier\", scramble_ratio=0.5, write=False) Enhanced Video Scrambling The updated scramblevideo function allows for more granular control over the video scrambling process, with the ability to specify detailed settings for the scrambleface function used internally. This update is particularly beneficial for use cases requiring consistent scrambling effects across different video frames or varied scrambling intensities throughout a video sequence. from scramblery import scramblevideo # Define custom settings for the video scrambling process scramble_settings = { 'splits': 20, 'type': 'fourier', 'scramble_ratio': 0.6, 'seamless': True, 'bg': False } # Apply scrambling to a video file scramblevideo(\"input_video.mp4\", \"output_scrambled_video.mp4\", scramble_settings)","title":"API"},{"location":"api_reference/#scramblery-functions-in-python","text":"Maintained by: @altunenes This document outlines the updated functionalities of the Scramblery library, including the newly introduced Fourier scrambling technique and the enhancements made to the video scrambling function.","title":"Scramblery Functions in Python"},{"location":"api_reference/#updates","text":"Fourier Scrambling : A novel method for image scrambling that operates in the frequency domain. Unlike traditional scrambling methods that shuffle pixel values or coordinates, Fourier scrambling randomizes the phase information of the image's Fourier transform, thereby disrupting the image's structure while preserving its energy distribution. This method is particularly potent for applications requiring non-reversible image transformations without a significant loss of information content (e.g., privacy preservation, data anonymization). Video Scrambling Enhancements : The scramblevideo function has been overhauled to provide more flexibility and control over the scrambling process. Users can now specify detailed scrambling settings, allowing for different scrambling techniques to be applied throughout a video sequence. This feature is crucial for researchers and practitioners working with video data, where consistent scrambling parameters are necessary across frames.","title":"Updates"},{"location":"api_reference/#function-documentation","text":"","title":"Function Documentation"},{"location":"api_reference/#scrambleface","text":"def scrambleface(img, splits, type, seamless=False, bg=True, seed=None, write=True, scramble_ratio=1.0): \"\"\" Scramble the facial area of the image. Args: img: input image path or image array splits: number of splits to perform, works differently between square and stack splits type: type of split, \"pixel\", \"stack\", or \"fourier\". Stack works with pixel coordinates, square works with pixel values seamless: if True, uses seamlessClone to blend the scrambled face with the original image bg: if True, uses the background of the original image, if False, replaces the background with a gray color seed: seed for random number generator (default: None) write: if True, writes the output image to disk, if False, returns the output image scramble_ratio: the power of Fourier scrambling (default: 1.0) Usage: scrambleface(\"image.png\", 10, \"fourier\", False, True, None, True, 0.5) \"\"\"","title":"scrambleface"},{"location":"api_reference/#scrambleimage","text":"def scrambleimage(image_path, x_block=10, y_block=10, scramble_type='classic', seed=None, write=True, **kwargs): \"\"\" Main function to scramble an image based on the specified scramble type. Args: image_path: Path to the input image (with extension). x_block: Number of splits in x-axis. y_block: Number of splits in y-axis. scramble_type: Type of split; valid values are \"classic\", \"pixel\", \"withinblocks\", \"rotate\", \"colormap\", \"gradient\", \"fourier\". seed: Seed for random number generator (default: None). write: Write the image to disk (default: True). **kwargs: Additional keyword arguments specific to scramble types. Returns: If write is True, writes the scrambled image to disk. If write is False, returns the scrambled image. Raises: ValueError: If an invalid scramble_type is provided or image cannot be read. FileNotFoundError: If the image_path does not exist. \"\"\"","title":"scrambleimage"},{"location":"api_reference/#scramblevideo","text":"def scramblevideo(input_video_path, output_video_path=None, scramble_settings=None): \"\"\" Scramble the facial area in a video. Args: input_video_path: Path to the input video. splits: Number of splits to perform on the face. output_video_path: Path where the output video will be saved (if None, the video won't be saved). scramble_settings: Dictionary of settings for the scrambleface function. Usage: scramblevideo(\"input_video.mp4\", 10, \"output_video.mp4\", scramble_settings) \"\"\"","title":"scramblevideo"},{"location":"api_reference/#usage-examples","text":"","title":"Usage Examples"},{"location":"api_reference/#fourier-scrambling","text":"The scrambleface and scrambleimage functions now support Fourier scrambling, a method that disrupts the image's visual content without altering its energy spectrum significantly. This technique is particularly useful in situations where the image's overall energy distribution must be maintained for subsequent processing steps (e.g., deep learning applications) or for privacy-preserving transformations. from scramblery import scrambleface, scrambleimage # Scramble the face in the image using the Fourier method scrambled_face = scrambleface(\"face.jpg\", splits=10, type=\"fourier\", scramble_ratio=0.7, write=False) # Scramble the entire image using the Fourier method scrambled_image = scrambleimage(\"image.jpg\", scramble_type=\"fourier\", scramble_ratio=0.5, write=False)","title":"Fourier Scrambling"},{"location":"api_reference/#enhanced-video-scrambling","text":"The updated scramblevideo function allows for more granular control over the video scrambling process, with the ability to specify detailed settings for the scrambleface function used internally. This update is particularly beneficial for use cases requiring consistent scrambling effects across different video frames or varied scrambling intensities throughout a video sequence. from scramblery import scramblevideo # Define custom settings for the video scrambling process scramble_settings = { 'splits': 20, 'type': 'fourier', 'scramble_ratio': 0.6, 'seamless': True, 'bg': False } # Apply scrambling to a video file scramblevideo(\"input_video.mp4\", \"output_scrambled_video.mp4\", scramble_settings)","title":"Enhanced Video Scrambling"},{"location":"userguide/","text":"Installation The package can be found in pypi. To install the package, run the following command in the terminal: pip install scramblery Dependencies To use the scramblery package, the following Python packages need to be installed. You can install them using pip : pip install mediapipe pip install opencv-python pip install numpy Usage import the package: from scramblery import scramblery The package has 3 functions to use. Use the functions in the following manner: scramblery.scrambleimage(\"Lena.png\",8,8) scramblery.scrambleface(\"Lena.png\",8) Sometimes there may be some errors related to the size of the image when splitting into squares. Therefore, you may need to edit the number you will reserve. I will fix this issue in future releases. If you want to scramble multiple images you can use following code for best results. This will make sure that the same blocks are scrambled in all images. import glob #input folder containing the images to be scrambled (in this case, the folder is called 'inputfolder' in my working directory) input_dir = 'inputfolder' #output folder where the scrambled images will be saved output_dir = 'output' image_files = glob.glob(os.path.join(input_dir, '*.*')) for image_file in image_files: #scramble the image but don't write it to disk (write=False) image=scrambleimage(image_file, scramble_type='pixel', write=False) #get the base name of the image file base_name = os.path.splitext(os.path.basename(image_file))[0] #create the output file name by appending '_scrambled.jpg' to the base name. You can change the extension to .png or .jpg output_file = os.path.join(output_dir, base_name + '_scrambled.png') #write the scrambled image to disk (using the output file name) cv2.imwrite(output_file, image) Note that, this is only for the new output folder. If you want to scramble the images in your working directory it is more simple. You can use the following code. import glob input_dir = 'inputfolder' image_files = glob.glob(os.path.join(input_dir, '*.*')) for image_file in image_files: #scramble the images and write them into the your working directory. image=scrambleimage(image_file, scramble_type='pixel', write=True) This was a simple example of how to use the scrambleimage function to scramble multiple images. You can easily modify the code to suit your needs. Scrambling Faces in Videos The scramblevideo function allows you to scramble faces within a video. It's perfect for studies involving dynamic stimuli or any application where you need to anonymize faces in motion. Here's how to use it: from scramblery import scramblery # Path to the input video input_video_path = \"enes23.mp4\" # Path where the output video will be saved output_video_path = \"enes2555.mp4\" # Scramble settings scramble_settings = { 'splits': 25, # Number of splits to perform on the face 'type': 'pixel', # Type of scrambling ('pixel', 'classic', etc.) 'seamless': False, # Whether to use seamless cloning (True or False) 'bg': True, # Whether to include background scrambling (True or False) 'seed': None, # Seed for random number generator (None for random seed) 'write': False # Must always be False for video processing } # Call the function scramblery.scramblevideo(input_video_path, output_video_path, scramble_settings) Detailed Explanation input_video_path : The path to the video file you wish to process. output_video_path : The path where the scrambled video will be saved. If you don't want to save the video, set this to None . scramble_settings : A dictionary of settings that dictate how the video will be scrambled. splits : Determines how many blocks the face will be split into. A higher number means more, smaller blocks. type : The type of scrambling. Options include 'pixel', 'classic', 'fourier', etc. bg : If True , the background will also be scrambled, not just the face. seed : A seed for the random number generator, ensuring the same scrambling is applied across different calls. If None , the seed will be random. write : This should always be False for video processing, as the function handles the writing process. Performance Note Processing videos, especially long ones, can be time-consuming and computationally expensive. The time it takes to process a video largely depends on the length of the video, the resolution, the splits parameter, and the hardware of your computer. Ensure your system is adequately equipped to handle the processing, and expect this operation to be more time-consuming than processing images.","title":"User Guide"},{"location":"userguide/#installation","text":"The package can be found in pypi. To install the package, run the following command in the terminal: pip install scramblery","title":"Installation"},{"location":"userguide/#dependencies","text":"To use the scramblery package, the following Python packages need to be installed. You can install them using pip : pip install mediapipe pip install opencv-python pip install numpy","title":"Dependencies"},{"location":"userguide/#usage","text":"import the package: from scramblery import scramblery The package has 3 functions to use. Use the functions in the following manner: scramblery.scrambleimage(\"Lena.png\",8,8) scramblery.scrambleface(\"Lena.png\",8) Sometimes there may be some errors related to the size of the image when splitting into squares. Therefore, you may need to edit the number you will reserve. I will fix this issue in future releases. If you want to scramble multiple images you can use following code for best results. This will make sure that the same blocks are scrambled in all images. import glob #input folder containing the images to be scrambled (in this case, the folder is called 'inputfolder' in my working directory) input_dir = 'inputfolder' #output folder where the scrambled images will be saved output_dir = 'output' image_files = glob.glob(os.path.join(input_dir, '*.*')) for image_file in image_files: #scramble the image but don't write it to disk (write=False) image=scrambleimage(image_file, scramble_type='pixel', write=False) #get the base name of the image file base_name = os.path.splitext(os.path.basename(image_file))[0] #create the output file name by appending '_scrambled.jpg' to the base name. You can change the extension to .png or .jpg output_file = os.path.join(output_dir, base_name + '_scrambled.png') #write the scrambled image to disk (using the output file name) cv2.imwrite(output_file, image) Note that, this is only for the new output folder. If you want to scramble the images in your working directory it is more simple. You can use the following code. import glob input_dir = 'inputfolder' image_files = glob.glob(os.path.join(input_dir, '*.*')) for image_file in image_files: #scramble the images and write them into the your working directory. image=scrambleimage(image_file, scramble_type='pixel', write=True) This was a simple example of how to use the scrambleimage function to scramble multiple images. You can easily modify the code to suit your needs.","title":"Usage"},{"location":"userguide/#scrambling-faces-in-videos","text":"The scramblevideo function allows you to scramble faces within a video. It's perfect for studies involving dynamic stimuli or any application where you need to anonymize faces in motion. Here's how to use it: from scramblery import scramblery # Path to the input video input_video_path = \"enes23.mp4\" # Path where the output video will be saved output_video_path = \"enes2555.mp4\" # Scramble settings scramble_settings = { 'splits': 25, # Number of splits to perform on the face 'type': 'pixel', # Type of scrambling ('pixel', 'classic', etc.) 'seamless': False, # Whether to use seamless cloning (True or False) 'bg': True, # Whether to include background scrambling (True or False) 'seed': None, # Seed for random number generator (None for random seed) 'write': False # Must always be False for video processing } # Call the function scramblery.scramblevideo(input_video_path, output_video_path, scramble_settings)","title":"Scrambling Faces in Videos"},{"location":"userguide/#detailed-explanation","text":"input_video_path : The path to the video file you wish to process. output_video_path : The path where the scrambled video will be saved. If you don't want to save the video, set this to None . scramble_settings : A dictionary of settings that dictate how the video will be scrambled. splits : Determines how many blocks the face will be split into. A higher number means more, smaller blocks. type : The type of scrambling. Options include 'pixel', 'classic', 'fourier', etc. bg : If True , the background will also be scrambled, not just the face. seed : A seed for the random number generator, ensuring the same scrambling is applied across different calls. If None , the seed will be random. write : This should always be False for video processing, as the function handles the writing process.","title":"Detailed Explanation"},{"location":"userguide/#performance-note","text":"Processing videos, especially long ones, can be time-consuming and computationally expensive. The time it takes to process a video largely depends on the length of the video, the resolution, the splits parameter, and the hardware of your computer. Ensure your system is adequately equipped to handle the processing, and expect this operation to be more time-consuming than processing images.","title":"Performance Note"},{"location":"node_modules/fft.js/","text":"FFT.js Implementation of Radix-4 FFT. Usage const FFT = require('fft.js'); const f = new FFT(4096); const input = new Array(4096); input.fill(0); const out = f.createComplexArray(); If data has just real numbers as is the case when toComplexArray is used - real FFT may be run to compute it 25% faster: const realInput = new Array(f.size); f.realTransform(out, realInput); realTransform fills just the left half of the out , so if the full spectrum is needed (which is symmetric), do the following: f.completeSpectrum(out); If data on other hand is a complex array: const data = f.toComplexArray(input); f.transform(out, data); Inverse fourier transform: f.inverseTransform(data, out); Benchmarks $ npm run bench ===== table construction ===== fft.js x 1,426 ops/sec \u00b10.70% (93 runs sampled) Fastest is fft.js ===== transform size=2048 ===== fft.js x 35,153 ops/sec \u00b10.83% (94 runs sampled) jensnockert x 5,037 ops/sec \u00b10.98% (91 runs sampled) dsp.js x 23,143 ops/sec \u00b10.64% (96 runs sampled) drom x 14,372 ops/sec \u00b10.76% (92 runs sampled) Fastest is fft.js ===== transform size=4096 ===== fft.js x 15,676 ops/sec \u00b10.76% (94 runs sampled) jensnockert x 3,864 ops/sec \u00b11.02% (93 runs sampled) dsp.js x 7,905 ops/sec \u00b10.50% (97 runs sampled) drom x 6,718 ops/sec \u00b10.78% (96 runs sampled) Fastest is fft.js ===== transform size=8192 ===== fft.js x 6,896 ops/sec \u00b10.79% (96 runs sampled) jensnockert x 1,193 ops/sec \u00b10.73% (94 runs sampled) dsp.js x 2,300 ops/sec \u00b10.74% (95 runs sampled) drom x 3,164 ops/sec \u00b10.67% (95 runs sampled) Fastest is fft.js ===== transform size=16384 ===== fft.js x 3,123 ops/sec \u00b10.84% (95 runs sampled) jensnockert x 855 ops/sec \u00b11.02% (92 runs sampled) dsp.js x 948 ops/sec \u00b10.70% (94 runs sampled) drom x 1,428 ops/sec \u00b10.56% (93 runs sampled) Fastest is fft.js ===== realTransform size=2048 ===== fft.js x 47,511 ops/sec \u00b10.93% (91 runs sampled) fourier-transform x 34,859 ops/sec \u00b10.77% (93 runs sampled) Fastest is fft.js ===== realTransform size=4096 ===== fft.js x 21,841 ops/sec \u00b10.70% (94 runs sampled) fourier-transform x 16,135 ops/sec \u00b10.39% (93 runs sampled) Fastest is fft.js ===== realTransform size=8192 ===== fft.js x 9,665 ops/sec \u00b10.65% (95 runs sampled) fourier-transform x 6,456 ops/sec \u00b10.83% (93 runs sampled) Fastest is fft.js ===== realTransform size=16384 ===== fft.js x 4,399 ops/sec \u00b10.82% (93 runs sampled) fourier-transform x 2,745 ops/sec \u00b10.68% (94 runs sampled) Fastest is fft.js API Details Constructor const FFT = require('fft.js'); const fft = new FFT(size); NOTE: size MUST be a power of two and MUST be bigger than 1. If you are looking to find the nearest power of 2 given the size of your dataset, here is a good tutorial Input/Output formats and helper methods. fft.createComplexArray() Create an array of size equal to fft.size * 2 . This array contains fft.size complex numbers whose real and imaginary parts are interleaved like this: const complexArray = [ real0, imaginary0, real1, imaginary1, ... ]; fft.toComplexArray(realInput, /* optional */ storage) Use provided storage or create a new complex array and fill all real slots with values from realInput array, and all imaginary slots with zeroes. NOTE: Always provide storage for better performance and to avoid extra time in Garbage Collection. fft.fromComplexArray(complexInput, /* optional */ storage) Use provided storage or create an array of size fft.size and fill it with real values from the complexInput . NOTE: Imaginary values from complexInput are ignored. This is a convenience method. NOTE: Always provide storage for better performance and to avoid extra time in Garbage Collection. fft.completeSpectrum(spectrum) Fill the right half of spectrum complex array (See: fft.createComplexArray() ) with the complex conjugates of the left half: for (every every `i` between 1 and (N / 2 - 1)) spectrum[N - i] = spectrum*[i] NOTE: This method may be used with fft.realTransform() if full output is desired. FFT Methods fft.realTransform(output, input) Take array of real numbers input and perform FFT transformation on it, filling the left half of the output with the real part of the Fourier Transform's complex output (See: fft.completeSpectrum() ). NOTE: Always use this method if the input for FFT transformation is real (has no imaginary parts). It is about 40% faster to do such transformation this way. NOTE: input - real array of size fft.size , output - complex array (See: fft.createComplexArray() ). fft.transform(output, input) Perform transformation on complex input array and store results in the complex output array. NOTE: input and output are complex arrays (See: fft.createComplexArray() ). fft.inverseTransform(output, input) Perform inverse Fourier transform on complex input array and store results in the complex output array. NOTE: input and output are complex arrays (See: fft.createComplexArray() ). LICENSE This software is licensed under the MIT License. Copyright Fedor Indutny, 2017. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"FFT.js"},{"location":"node_modules/fft.js/#fftjs","text":"Implementation of Radix-4 FFT.","title":"FFT.js"},{"location":"node_modules/fft.js/#usage","text":"const FFT = require('fft.js'); const f = new FFT(4096); const input = new Array(4096); input.fill(0); const out = f.createComplexArray(); If data has just real numbers as is the case when toComplexArray is used - real FFT may be run to compute it 25% faster: const realInput = new Array(f.size); f.realTransform(out, realInput); realTransform fills just the left half of the out , so if the full spectrum is needed (which is symmetric), do the following: f.completeSpectrum(out); If data on other hand is a complex array: const data = f.toComplexArray(input); f.transform(out, data); Inverse fourier transform: f.inverseTransform(data, out);","title":"Usage"},{"location":"node_modules/fft.js/#benchmarks","text":"$ npm run bench ===== table construction ===== fft.js x 1,426 ops/sec \u00b10.70% (93 runs sampled) Fastest is fft.js ===== transform size=2048 ===== fft.js x 35,153 ops/sec \u00b10.83% (94 runs sampled) jensnockert x 5,037 ops/sec \u00b10.98% (91 runs sampled) dsp.js x 23,143 ops/sec \u00b10.64% (96 runs sampled) drom x 14,372 ops/sec \u00b10.76% (92 runs sampled) Fastest is fft.js ===== transform size=4096 ===== fft.js x 15,676 ops/sec \u00b10.76% (94 runs sampled) jensnockert x 3,864 ops/sec \u00b11.02% (93 runs sampled) dsp.js x 7,905 ops/sec \u00b10.50% (97 runs sampled) drom x 6,718 ops/sec \u00b10.78% (96 runs sampled) Fastest is fft.js ===== transform size=8192 ===== fft.js x 6,896 ops/sec \u00b10.79% (96 runs sampled) jensnockert x 1,193 ops/sec \u00b10.73% (94 runs sampled) dsp.js x 2,300 ops/sec \u00b10.74% (95 runs sampled) drom x 3,164 ops/sec \u00b10.67% (95 runs sampled) Fastest is fft.js ===== transform size=16384 ===== fft.js x 3,123 ops/sec \u00b10.84% (95 runs sampled) jensnockert x 855 ops/sec \u00b11.02% (92 runs sampled) dsp.js x 948 ops/sec \u00b10.70% (94 runs sampled) drom x 1,428 ops/sec \u00b10.56% (93 runs sampled) Fastest is fft.js ===== realTransform size=2048 ===== fft.js x 47,511 ops/sec \u00b10.93% (91 runs sampled) fourier-transform x 34,859 ops/sec \u00b10.77% (93 runs sampled) Fastest is fft.js ===== realTransform size=4096 ===== fft.js x 21,841 ops/sec \u00b10.70% (94 runs sampled) fourier-transform x 16,135 ops/sec \u00b10.39% (93 runs sampled) Fastest is fft.js ===== realTransform size=8192 ===== fft.js x 9,665 ops/sec \u00b10.65% (95 runs sampled) fourier-transform x 6,456 ops/sec \u00b10.83% (93 runs sampled) Fastest is fft.js ===== realTransform size=16384 ===== fft.js x 4,399 ops/sec \u00b10.82% (93 runs sampled) fourier-transform x 2,745 ops/sec \u00b10.68% (94 runs sampled) Fastest is fft.js","title":"Benchmarks"},{"location":"node_modules/fft.js/#api-details","text":"","title":"API Details"},{"location":"node_modules/fft.js/#constructor","text":"const FFT = require('fft.js'); const fft = new FFT(size); NOTE: size MUST be a power of two and MUST be bigger than 1. If you are looking to find the nearest power of 2 given the size of your dataset, here is a good tutorial","title":"Constructor"},{"location":"node_modules/fft.js/#inputoutput-formats-and-helper-methods","text":"","title":"Input/Output formats and helper methods."},{"location":"node_modules/fft.js/#fftcreatecomplexarray","text":"Create an array of size equal to fft.size * 2 . This array contains fft.size complex numbers whose real and imaginary parts are interleaved like this: const complexArray = [ real0, imaginary0, real1, imaginary1, ... ];","title":"fft.createComplexArray()"},{"location":"node_modules/fft.js/#ffttocomplexarrayrealinput-optional-storage","text":"Use provided storage or create a new complex array and fill all real slots with values from realInput array, and all imaginary slots with zeroes. NOTE: Always provide storage for better performance and to avoid extra time in Garbage Collection.","title":"fft.toComplexArray(realInput, /* optional */ storage)"},{"location":"node_modules/fft.js/#fftfromcomplexarraycomplexinput-optional-storage","text":"Use provided storage or create an array of size fft.size and fill it with real values from the complexInput . NOTE: Imaginary values from complexInput are ignored. This is a convenience method. NOTE: Always provide storage for better performance and to avoid extra time in Garbage Collection.","title":"fft.fromComplexArray(complexInput, /* optional */ storage)"},{"location":"node_modules/fft.js/#fftcompletespectrumspectrum","text":"Fill the right half of spectrum complex array (See: fft.createComplexArray() ) with the complex conjugates of the left half: for (every every `i` between 1 and (N / 2 - 1)) spectrum[N - i] = spectrum*[i] NOTE: This method may be used with fft.realTransform() if full output is desired.","title":"fft.completeSpectrum(spectrum)"},{"location":"node_modules/fft.js/#fft-methods","text":"","title":"FFT Methods"},{"location":"node_modules/fft.js/#fftrealtransformoutput-input","text":"Take array of real numbers input and perform FFT transformation on it, filling the left half of the output with the real part of the Fourier Transform's complex output (See: fft.completeSpectrum() ). NOTE: Always use this method if the input for FFT transformation is real (has no imaginary parts). It is about 40% faster to do such transformation this way. NOTE: input - real array of size fft.size , output - complex array (See: fft.createComplexArray() ).","title":"fft.realTransform(output, input)"},{"location":"node_modules/fft.js/#ffttransformoutput-input","text":"Perform transformation on complex input array and store results in the complex output array. NOTE: input and output are complex arrays (See: fft.createComplexArray() ).","title":"fft.transform(output, input)"},{"location":"node_modules/fft.js/#fftinversetransformoutput-input","text":"Perform inverse Fourier transform on complex input array and store results in the complex output array. NOTE: input and output are complex arrays (See: fft.createComplexArray() ).","title":"fft.inverseTransform(output, input)"},{"location":"node_modules/fft.js/#license","text":"This software is licensed under the MIT License. Copyright Fedor Indutny, 2017. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"LICENSE"}]}